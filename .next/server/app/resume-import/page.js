(() => {
var exports = {};
exports.id = 860;
exports.ids = [860];
exports.modules = {

/***/ 252:
/***/ ((module) => {

"use strict";
module.exports = require("next/dist/compiled/cookie");

/***/ }),

/***/ 7999:
/***/ ((module) => {

"use strict";
module.exports = require("next/dist/compiled/path-to-regexp");

/***/ }),

/***/ 8038:
/***/ ((module) => {

"use strict";
module.exports = require("next/dist/compiled/react");

/***/ }),

/***/ 8704:
/***/ ((module) => {

"use strict";
module.exports = require("next/dist/compiled/react-dom/server-rendering-stub");

/***/ }),

/***/ 7897:
/***/ ((module) => {

"use strict";
module.exports = require("next/dist/compiled/react-server-dom-webpack/client");

/***/ }),

/***/ 6786:
/***/ ((module) => {

"use strict";
module.exports = require("next/dist/compiled/react/jsx-runtime");

/***/ }),

/***/ 1090:
/***/ ((module) => {

"use strict";
module.exports = require("next/dist/server/app-render/get-segment-param.js");

/***/ }),

/***/ 8652:
/***/ ((module) => {

"use strict";
module.exports = require("next/dist/server/future/helpers/interception-routes.js");

/***/ }),

/***/ 3918:
/***/ ((module) => {

"use strict";
module.exports = require("next/dist/shared/lib/amp-context.js");

/***/ }),

/***/ 5732:
/***/ ((module) => {

"use strict";
module.exports = require("next/dist/shared/lib/amp-mode.js");

/***/ }),

/***/ 3280:
/***/ ((module) => {

"use strict";
module.exports = require("next/dist/shared/lib/app-router-context.js");

/***/ }),

/***/ 2796:
/***/ ((module) => {

"use strict";
module.exports = require("next/dist/shared/lib/head-manager-context.js");

/***/ }),

/***/ 9274:
/***/ ((module) => {

"use strict";
module.exports = require("next/dist/shared/lib/hooks-client-context.js");

/***/ }),

/***/ 4486:
/***/ ((module) => {

"use strict";
module.exports = require("next/dist/shared/lib/image-blur-svg.js");

/***/ }),

/***/ 744:
/***/ ((module) => {

"use strict";
module.exports = require("next/dist/shared/lib/image-config-context.js");

/***/ }),

/***/ 5843:
/***/ ((module) => {

"use strict";
module.exports = require("next/dist/shared/lib/image-config.js");

/***/ }),

/***/ 9552:
/***/ ((module) => {

"use strict";
module.exports = require("next/dist/shared/lib/image-loader");

/***/ }),

/***/ 4964:
/***/ ((module) => {

"use strict";
module.exports = require("next/dist/shared/lib/router-context.js");

/***/ }),

/***/ 1751:
/***/ ((module) => {

"use strict";
module.exports = require("next/dist/shared/lib/router/utils/add-path-prefix.js");

/***/ }),

/***/ 3938:
/***/ ((module) => {

"use strict";
module.exports = require("next/dist/shared/lib/router/utils/format-url.js");

/***/ }),

/***/ 1668:
/***/ ((module) => {

"use strict";
module.exports = require("next/dist/shared/lib/router/utils/handle-smooth-scroll.js");

/***/ }),

/***/ 1897:
/***/ ((module) => {

"use strict";
module.exports = require("next/dist/shared/lib/router/utils/is-bot.js");

/***/ }),

/***/ 1109:
/***/ ((module) => {

"use strict";
module.exports = require("next/dist/shared/lib/router/utils/is-local-url.js");

/***/ }),

/***/ 8854:
/***/ ((module) => {

"use strict";
module.exports = require("next/dist/shared/lib/router/utils/parse-path.js");

/***/ }),

/***/ 3297:
/***/ ((module) => {

"use strict";
module.exports = require("next/dist/shared/lib/router/utils/remove-trailing-slash.js");

/***/ }),

/***/ 7782:
/***/ ((module) => {

"use strict";
module.exports = require("next/dist/shared/lib/router/utils/resolve-href.js");

/***/ }),

/***/ 3349:
/***/ ((module) => {

"use strict";
module.exports = require("next/dist/shared/lib/server-inserted-html.js");

/***/ }),

/***/ 2470:
/***/ ((module) => {

"use strict";
module.exports = require("next/dist/shared/lib/side-effect.js");

/***/ }),

/***/ 9232:
/***/ ((module) => {

"use strict";
module.exports = require("next/dist/shared/lib/utils.js");

/***/ }),

/***/ 618:
/***/ ((module) => {

"use strict";
module.exports = require("next/dist/shared/lib/utils/warn-once.js");

/***/ }),

/***/ 7147:
/***/ ((module) => {

"use strict";
module.exports = require("fs");

/***/ }),

/***/ 3685:
/***/ ((module) => {

"use strict";
module.exports = require("http");

/***/ }),

/***/ 5687:
/***/ ((module) => {

"use strict";
module.exports = require("https");

/***/ }),

/***/ 1017:
/***/ ((module) => {

"use strict";
module.exports = require("path");

/***/ }),

/***/ 7310:
/***/ ((module) => {

"use strict";
module.exports = require("url");

/***/ }),

/***/ 9796:
/***/ ((module) => {

"use strict";
module.exports = require("zlib");

/***/ }),

/***/ 3414:
/***/ (() => {

/* (ignored) */

/***/ }),

/***/ 5566:
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "AppRouter": () => (/* reexport default from dynamic */ next_dist_client_components_app_router__WEBPACK_IMPORTED_MODULE_0___default.a),
/* harmony export */   "GlobalError": () => (/* reexport default from dynamic */ next_dist_client_components_error_boundary__WEBPACK_IMPORTED_MODULE_3___default.a),
/* harmony export */   "LayoutRouter": () => (/* reexport default from dynamic */ next_dist_client_components_layout_router__WEBPACK_IMPORTED_MODULE_1___default.a),
/* harmony export */   "RenderFromTemplateContext": () => (/* reexport default from dynamic */ next_dist_client_components_render_from_template_context__WEBPACK_IMPORTED_MODULE_2___default.a),
/* harmony export */   "StaticGenerationSearchParamsBailoutProvider": () => (/* reexport default from dynamic */ next_dist_client_components_static_generation_searchparams_bailout_provider__WEBPACK_IMPORTED_MODULE_8___default.a),
/* harmony export */   "__next_app_webpack_require__": () => (/* binding */ __next_app_webpack_require__),
/* harmony export */   "actionAsyncStorage": () => (/* reexport safe */ next_dist_client_components_action_async_storage__WEBPACK_IMPORTED_MODULE_6__.actionAsyncStorage),
/* harmony export */   "createSearchParamsBailoutProxy": () => (/* reexport safe */ next_dist_client_components_searchparams_bailout_proxy__WEBPACK_IMPORTED_MODULE_9__.createSearchParamsBailoutProxy),
/* harmony export */   "decodeAction": () => (/* reexport safe */ react_server_dom_webpack_server_edge__WEBPACK_IMPORTED_MODULE_11__.decodeAction),
/* harmony export */   "decodeReply": () => (/* reexport safe */ react_server_dom_webpack_server_edge__WEBPACK_IMPORTED_MODULE_11__.decodeReply),
/* harmony export */   "originalPathname": () => (/* binding */ originalPathname),
/* harmony export */   "pages": () => (/* binding */ pages),
/* harmony export */   "preconnect": () => (/* reexport safe */ next_dist_server_app_render_rsc_preloads__WEBPACK_IMPORTED_MODULE_12__.preconnect),
/* harmony export */   "preloadFont": () => (/* reexport safe */ next_dist_server_app_render_rsc_preloads__WEBPACK_IMPORTED_MODULE_12__.preloadFont),
/* harmony export */   "preloadStyle": () => (/* reexport safe */ next_dist_server_app_render_rsc_preloads__WEBPACK_IMPORTED_MODULE_12__.preloadStyle),
/* harmony export */   "renderToReadableStream": () => (/* reexport safe */ react_server_dom_webpack_server_edge__WEBPACK_IMPORTED_MODULE_11__.renderToReadableStream),
/* harmony export */   "requestAsyncStorage": () => (/* reexport safe */ next_dist_client_components_request_async_storage__WEBPACK_IMPORTED_MODULE_5__.requestAsyncStorage),
/* harmony export */   "serverHooks": () => (/* reexport module object */ next_dist_client_components_hooks_server_context__WEBPACK_IMPORTED_MODULE_10__),
/* harmony export */   "staticGenerationAsyncStorage": () => (/* reexport safe */ next_dist_client_components_static_generation_async_storage__WEBPACK_IMPORTED_MODULE_4__.staticGenerationAsyncStorage),
/* harmony export */   "staticGenerationBailout": () => (/* reexport safe */ next_dist_client_components_static_generation_bailout__WEBPACK_IMPORTED_MODULE_7__.staticGenerationBailout),
/* harmony export */   "tree": () => (/* binding */ tree)
/* harmony export */ });
/* harmony import */ var next_dist_client_components_app_router__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(4592);
/* harmony import */ var next_dist_client_components_app_router__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(next_dist_client_components_app_router__WEBPACK_IMPORTED_MODULE_0__);
/* harmony import */ var next_dist_client_components_layout_router__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(6301);
/* harmony import */ var next_dist_client_components_layout_router__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(next_dist_client_components_layout_router__WEBPACK_IMPORTED_MODULE_1__);
/* harmony import */ var next_dist_client_components_render_from_template_context__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(7431);
/* harmony import */ var next_dist_client_components_render_from_template_context__WEBPACK_IMPORTED_MODULE_2___default = /*#__PURE__*/__webpack_require__.n(next_dist_client_components_render_from_template_context__WEBPACK_IMPORTED_MODULE_2__);
/* harmony import */ var next_dist_client_components_error_boundary__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(2673);
/* harmony import */ var next_dist_client_components_error_boundary__WEBPACK_IMPORTED_MODULE_3___default = /*#__PURE__*/__webpack_require__.n(next_dist_client_components_error_boundary__WEBPACK_IMPORTED_MODULE_3__);
/* harmony import */ var next_dist_client_components_static_generation_async_storage__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(94);
/* harmony import */ var next_dist_client_components_static_generation_async_storage__WEBPACK_IMPORTED_MODULE_4___default = /*#__PURE__*/__webpack_require__.n(next_dist_client_components_static_generation_async_storage__WEBPACK_IMPORTED_MODULE_4__);
/* harmony import */ var next_dist_client_components_request_async_storage__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(4437);
/* harmony import */ var next_dist_client_components_request_async_storage__WEBPACK_IMPORTED_MODULE_5___default = /*#__PURE__*/__webpack_require__.n(next_dist_client_components_request_async_storage__WEBPACK_IMPORTED_MODULE_5__);
/* harmony import */ var next_dist_client_components_action_async_storage__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(6127);
/* harmony import */ var next_dist_client_components_action_async_storage__WEBPACK_IMPORTED_MODULE_6___default = /*#__PURE__*/__webpack_require__.n(next_dist_client_components_action_async_storage__WEBPACK_IMPORTED_MODULE_6__);
/* harmony import */ var next_dist_client_components_static_generation_bailout__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(5486);
/* harmony import */ var next_dist_client_components_static_generation_bailout__WEBPACK_IMPORTED_MODULE_7___default = /*#__PURE__*/__webpack_require__.n(next_dist_client_components_static_generation_bailout__WEBPACK_IMPORTED_MODULE_7__);
/* harmony import */ var next_dist_client_components_static_generation_searchparams_bailout_provider__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(6404);
/* harmony import */ var next_dist_client_components_static_generation_searchparams_bailout_provider__WEBPACK_IMPORTED_MODULE_8___default = /*#__PURE__*/__webpack_require__.n(next_dist_client_components_static_generation_searchparams_bailout_provider__WEBPACK_IMPORTED_MODULE_8__);
/* harmony import */ var next_dist_client_components_searchparams_bailout_proxy__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(2527);
/* harmony import */ var next_dist_client_components_searchparams_bailout_proxy__WEBPACK_IMPORTED_MODULE_9___default = /*#__PURE__*/__webpack_require__.n(next_dist_client_components_searchparams_bailout_proxy__WEBPACK_IMPORTED_MODULE_9__);
/* harmony import */ var next_dist_client_components_hooks_server_context__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__(3332);
/* harmony import */ var next_dist_client_components_hooks_server_context__WEBPACK_IMPORTED_MODULE_10___default = /*#__PURE__*/__webpack_require__.n(next_dist_client_components_hooks_server_context__WEBPACK_IMPORTED_MODULE_10__);
/* harmony import */ var react_server_dom_webpack_server_edge__WEBPACK_IMPORTED_MODULE_11__ = __webpack_require__(7902);
/* harmony import */ var next_dist_server_app_render_rsc_preloads__WEBPACK_IMPORTED_MODULE_12__ = __webpack_require__(3099);
/* harmony import */ var next_dist_server_app_render_rsc_preloads__WEBPACK_IMPORTED_MODULE_12___default = /*#__PURE__*/__webpack_require__.n(next_dist_server_app_render_rsc_preloads__WEBPACK_IMPORTED_MODULE_12__);

    const tree = {
        children: [
        '',
        {
        children: [
        'resume-import',
        {
        children: ['__PAGE__', {}, {
          page: [() => Promise.resolve(/* import() eager */).then(__webpack_require__.bind(__webpack_require__, 2617)), "C:\\Users\\saura\\Downloads\\SmartCV-Resume-main\\SmartCV-Resume-main\\src\\app\\resume-import\\page.tsx"],
          
        }]
      },
        {
          
          metadata: {
    icon: [(async (props) => (await Promise.resolve(/* import() eager */).then(__webpack_require__.bind(__webpack_require__, 1764))).default(props))],
    apple: [],
    openGraph: [],
    twitter: [],
    manifest: undefined
  }
        }
      ]
      },
        {
          'layout': [() => Promise.resolve(/* import() eager */).then(__webpack_require__.bind(__webpack_require__, 5774)), "C:\\Users\\saura\\Downloads\\SmartCV-Resume-main\\SmartCV-Resume-main\\src\\app\\layout.tsx"],
          metadata: {
    icon: [(async (props) => (await Promise.resolve(/* import() eager */).then(__webpack_require__.bind(__webpack_require__, 1764))).default(props))],
    apple: [],
    openGraph: [],
    twitter: [],
    manifest: undefined
  }
        }
      ]
      }.children;
    const pages = ["C:\\Users\\saura\\Downloads\\SmartCV-Resume-main\\SmartCV-Resume-main\\src\\app\\resume-import\\page.tsx"];

    
    
    
    

    

    
    

    
    
    

    

    
    const __next_app_webpack_require__ = __webpack_require__
    

    const originalPathname = "/resume-import/page"
  

/***/ }),

/***/ 2201:
/***/ ((__unused_webpack_module, __unused_webpack_exports, __webpack_require__) => {

Promise.resolve(/* import() eager */).then(__webpack_require__.bind(__webpack_require__, 4394))

/***/ }),

/***/ 8277:
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "I": () => (/* binding */ deepClone)
/* harmony export */ });
/**
 * Server side object deep clone util using JSON serialization.
 * Not efficient for large objects but good enough for most use cases.
 *
 * Client side can simply use structuredClone.
 */ const deepClone = (object)=>JSON.parse(JSON.stringify(object));


/***/ }),

/***/ 4394:
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
// ESM COMPAT FLAG
__webpack_require__.r(__webpack_exports__);

// EXPORTS
__webpack_require__.d(__webpack_exports__, {
  "default": () => (/* binding */ ImportResume)
});

// EXTERNAL MODULE: external "next/dist/compiled/react/jsx-runtime"
var jsx_runtime_ = __webpack_require__(6786);
// EXTERNAL MODULE: ./src/app/lib/redux/local-storage.ts
var local_storage = __webpack_require__(7793);
// EXTERNAL MODULE: external "next/dist/compiled/react"
var react_ = __webpack_require__(8038);
// EXTERNAL MODULE: ./node_modules/@heroicons/react/24/solid/esm/LockClosedIcon.js
var LockClosedIcon = __webpack_require__(3289);
// EXTERNAL MODULE: ./node_modules/@heroicons/react/24/outline/esm/XMarkIcon.js
var XMarkIcon = __webpack_require__(1966);
// EXTERNAL MODULE: ./node_modules/pdfjs-dist/build/pdf.js
var pdf = __webpack_require__(2709);
// EXTERNAL MODULE: ./node_modules/pdfjs-dist/build/pdf.worker.entry.js
var pdf_worker_entry = __webpack_require__(1749);
var pdf_worker_entry_default = /*#__PURE__*/__webpack_require__.n(pdf_worker_entry);
;// CONCATENATED MODULE: ./src/app/lib/parse-resume-from-pdf/read-pdf.ts
// Getting pdfjs to work is tricky. The following 3 lines would make it work
// https://stackoverflow.com/a/63486898/7699841

// @ts-ignore

pdf.GlobalWorkerOptions.workerSrc = (pdf_worker_entry_default());
/**
 * Step 1: Read pdf and output textItems by concatenating results from each page.
 *
 * To make processing easier, it returns a new TextItem type, which removes unused
 * attributes (dir, transform), adds x and y positions, and replaces loaded font
 * name with original font name.
 *
 * @example
 * const onFileChange = async (e) => {
 *     const fileUrl = URL.createObjectURL(e.target.files[0]);
 *     const textItems = await readPdf(fileUrl);
 * }
 */ const readPdf = async (fileUrl)=>{
    const pdfFile = await pdf.getDocument(fileUrl).promise;
    let textItems = [];
    for(let i = 1; i <= pdfFile.numPages; i++){
        // Parse each page into text content
        const page = await pdfFile.getPage(i);
        const textContent = await page.getTextContent();
        // Wait for font data to be loaded
        await page.getOperatorList();
        const commonObjs = page.commonObjs;
        // Convert Pdfjs TextItem type to new TextItem type
        const pageTextItems = textContent.items.map((item)=>{
            const { str: text , dir , transform , fontName: pdfFontName , ...otherProps } = item;
            // Extract x, y position of text item from transform.
            // As a side note, origin (0, 0) is bottom left.
            // Reference: https://github.com/mozilla/pdf.js/issues/5643#issuecomment-496648719
            const x = transform[4];
            const y = transform[5];
            // Use commonObjs to convert font name to original name (e.g. "GVDLYI+Arial-BoldMT")
            // since non system font name by default is a loaded name, e.g. "g_d8_f1"
            // Reference: https://github.com/mozilla/pdf.js/pull/15659
            const fontObj = commonObjs.get(pdfFontName);
            const fontName = fontObj.name;
            // pdfjs reads a "-" as "-Â­â€" in the resume example. This is to revert it.
            // Note "-Â­â€" is "-&#x00AD;â€" with a soft hyphen in between. It is not the same as "--"
            const newText = text.replace(/-Â­â€/g, "-");
            const newItem = {
                ...otherProps,
                fontName,
                text: newText,
                x,
                y
            };
            return newItem;
        });
        // Some pdf's text items are not in order. This is most likely a result of creating it
        // from design softwares, e.g. canvas. The commented out method can sort pageTextItems
        // by y position to put them back in order. But it is not used since it might be more
        // helpful to let users know that the pdf is not in order.
        // pageTextItems.sort((a, b) => Math.round(b.y) - Math.round(a.y));
        // Add text items of each page to total
        textItems.push(...pageTextItems);
    }
    // Filter out empty space textItem noise
    const isEmptySpace = (textItem)=>!textItem.hasEOL && textItem.text.trim() === "";
    textItems = textItems.filter((textItem)=>!isEmptySpace(textItem));
    return textItems;
};

;// CONCATENATED MODULE: ./src/app/lib/parse-resume-from-pdf/extract-resume-from-sections/lib/bullet-points.ts
/**
 * List of bullet points
 * Reference: https://stackoverflow.com/questions/56540160/why-isnt-there-a-medium-small-black-circle-in-unicode
 * U+22C5   DOT OPERATOR (â‹…)
 * U+2219   BULLET OPERATOR (âˆ™)
 * U+1F784  BLACK SLIGHTLY SMALL CIRCLE (ðŸž„)
 * U+2022   BULLET (â€¢) -------- most common
 * U+2981   Z NOTATION SPOT (â¦)
 * U+26AB   MEDIUM BLACK CIRCLE (âš«ï¸Ž)
 * U+25CF   BLACK CIRCLE (â—)
 * U+2B24   BLACK LARGE CIRCLE (â¬¤)
 * U+26AC   MEDIUM SMALL WHITE CIRCLEâ€‚âš¬
 * U+25CB   WHITE CIRCLEâ€‚â—‹
 */ const BULLET_POINTS = [
    "â‹…",
    "âˆ™",
    "\uD83D\uDF84",
    "â€¢",
    "â¦",
    "âš«ï¸Ž",
    "â—",
    "â¬¤",
    "âš¬",
    "â—‹"
];
/**
 * Convert bullet point lines into a string array aka descriptions.
 */ const getBulletPointsFromLines = (lines)=>{
    // Simply return all lines with text item joined together if there is no bullet point
    const firstBulletPointLineIndex = getFirstBulletPointLineIdx(lines);
    if (firstBulletPointLineIndex === undefined) {
        return lines.map((line)=>line.map((item)=>item.text).join(" "));
    }
    // Otherwise, process and remove bullet points
    // Combine all lines into a single string
    let lineStr = "";
    for (let item of lines.flat()){
        const text = item.text;
        // Make sure a space is added between 2 words
        if (!lineStr.endsWith(" ") && !text.startsWith(" ")) {
            lineStr += " ";
        }
        lineStr += text;
    }
    // Get the most common bullet point
    const commonBulletPoint = getMostCommonBulletPoint(lineStr);
    // Start line string from the beginning of the first bullet point
    const firstBulletPointIndex = lineStr.indexOf(commonBulletPoint);
    if (firstBulletPointIndex !== -1) {
        lineStr = lineStr.slice(firstBulletPointIndex);
    }
    // Divide the single string using bullet point as divider
    return lineStr.split(commonBulletPoint).map((text)=>text.trim()).filter((text)=>!!text);
};
const getMostCommonBulletPoint = (str)=>{
    const bulletToCount = BULLET_POINTS.reduce((acc, cur)=>{
        acc[cur] = 0;
        return acc;
    }, {});
    let bulletWithMostCount = BULLET_POINTS[0];
    let bulletMaxCount = 0;
    for (let char of str){
        if (bulletToCount.hasOwnProperty(char)) {
            bulletToCount[char]++;
            if (bulletToCount[char] > bulletMaxCount) {
                bulletWithMostCount = char;
            }
        }
    }
    return bulletWithMostCount;
};
const getFirstBulletPointLineIdx = (lines)=>{
    for(let i = 0; i < lines.length; i++){
        for (let item of lines[i]){
            if (BULLET_POINTS.some((bullet)=>item.text.includes(bullet))) {
                return i;
            }
        }
    }
    return undefined;
};
// Only consider words that don't contain numbers
const isWord = (str)=>/^[^0-9]+$/.test(str);
const hasAtLeast8Words = (item)=>item.text.split(/\s/).filter(isWord).length >= 8;
const getDescriptionsLineIdx = (lines)=>{
    // The main heuristic to determine descriptions is to check if has bullet point
    let idx = getFirstBulletPointLineIdx(lines);
    // Fallback heuristic if the main heuristic doesn't apply (e.g. LinkedIn resume) to
    // check if the line has at least 8 words
    if (idx === undefined) {
        for(let i = 0; i < lines.length; i++){
            const line = lines[i];
            if (line.length === 1 && hasAtLeast8Words(line[0])) {
                idx = i;
                break;
            }
        }
    }
    return idx;
};

;// CONCATENATED MODULE: ./src/app/lib/parse-resume-from-pdf/group-text-items-into-lines.ts

/**
 * Step 2: Group text items into lines. This returns an array where each position
 * contains text items in the same line of the pdf file.
 */ const groupTextItemsIntoLines = (textItems)=>{
    const lines = [];
    // Group text items into lines based on hasEOL
    let line = [];
    for (let item of textItems){
        // If item is EOL, add current line to lines and start a new empty line
        if (item.hasEOL) {
            if (item.text.trim() !== "") {
                line.push({
                    ...item
                });
            }
            lines.push(line);
            line = [];
        } else if (item.text.trim() !== "") {
            line.push({
                ...item
            });
        }
    }
    // Add last line if there is item in last line
    if (line.length > 0) {
        lines.push(line);
    }
    // Many pdf docs are not well formatted, e.g. due to converting from other docs.
    // This creates many noises, where a single text item is divided into multiple
    // ones. This step is to merge adjacent text items if their distance is smaller
    // than a typical char width to filter out those noises.
    const typicalCharWidth = getTypicalCharWidth(lines.flat());
    for (let line of lines){
        // Start from the end of the line to make things easier to merge and delete
        for(let i = line.length - 1; i > 0; i--){
            const currentItem = line[i];
            const leftItem = line[i - 1];
            const leftItemXEnd = leftItem.x + leftItem.width;
            const distance = currentItem.x - leftItemXEnd;
            if (distance <= typicalCharWidth) {
                if (shouldAddSpaceBetweenText(leftItem.text, currentItem.text)) {
                    leftItem.text += " ";
                }
                leftItem.text += currentItem.text;
                // Update leftItem width to include currentItem after merge before deleting current item
                const currentItemXEnd = currentItem.x + currentItem.width;
                leftItem.width = currentItemXEnd - leftItem.x;
                line.splice(i, 1);
            }
        }
    }
    return lines;
};
// Sometimes a space is lost while merging adjacent text items. This accounts for some of those cases
const shouldAddSpaceBetweenText = (leftText, rightText)=>{
    const leftTextEnd = leftText[leftText.length - 1];
    const rightTextStart = rightText[0];
    const conditions = [
        [
            ":",
            ",",
            "|",
            ".",
            ...BULLET_POINTS
        ].includes(leftTextEnd) && rightTextStart !== " ",
        leftTextEnd !== " " && [
            "|",
            ...BULLET_POINTS
        ].includes(rightTextStart)
    ];
    return conditions.some((condition)=>condition);
};
/**
 * Return the width of a typical character. (Helper util for groupTextItemsIntoLines)
 *
 * A pdf file uses different characters, each with different width due to different
 * font family and font size. This util first extracts the most typically used font
 * family and font height, and compute the average character width using text items
 * that match the typical font family and height.
 */ const getTypicalCharWidth = (textItems)=>{
    // Exclude empty space " " in calculations since its width isn't precise
    textItems = textItems.filter((item)=>item.text.trim() !== "");
    const heightToCount = {};
    let commonHeight = 0;
    let heightMaxCount = 0;
    const fontNameToCount = {};
    let commonFontName = "";
    let fontNameMaxCount = 0;
    for (let item of textItems){
        const { text , height , fontName  } = item;
        // Process height
        if (!heightToCount[height]) {
            heightToCount[height] = 0;
        }
        heightToCount[height]++;
        if (heightToCount[height] > heightMaxCount) {
            commonHeight = height;
            heightMaxCount = heightToCount[height];
        }
        // Process font name
        if (!fontNameToCount[fontName]) {
            fontNameToCount[fontName] = 0;
        }
        fontNameToCount[fontName] += text.length;
        if (fontNameToCount[fontName] > fontNameMaxCount) {
            commonFontName = fontName;
            fontNameMaxCount = fontNameToCount[fontName];
        }
    }
    // Find the text items that match common font family and height
    const commonTextItems = textItems.filter((item)=>item.fontName === commonFontName && item.height === commonHeight);
    // Aggregate total width and number of characters of all common text items
    const [totalWidth, numChars] = commonTextItems.reduce((acc, cur)=>{
        const [preWidth, prevChars] = acc;
        return [
            preWidth + cur.width,
            prevChars + cur.text.length
        ];
    }, [
        0,
        0
    ]);
    const typicalCharWidth = totalWidth / numChars;
    return typicalCharWidth;
};

;// CONCATENATED MODULE: ./src/app/lib/parse-resume-from-pdf/extract-resume-from-sections/lib/common-features.ts
const isTextItemBold = (fontName)=>fontName.toLowerCase().includes("bold");
const isBold = (item)=>isTextItemBold(item.fontName);
const hasLetter = (item)=>/[a-zA-Z]/.test(item.text);
const hasNumber = (item)=>/[0-9]/.test(item.text);
const hasComma = (item)=>item.text.includes(",");
const getHasText = (text)=>(item)=>item.text.includes(text);
const hasOnlyLettersSpacesAmpersands = (item)=>/^[A-Za-z\s&]+$/.test(item.text);
const hasLetterAndIsAllUpperCase = (item)=>hasLetter(item) && item.text.toUpperCase() === item.text;
// Date Features
const hasYear = (item)=>/(?:19|20)\d{2}/.test(item.text);
// prettier-ignore
const MONTHS = [
    "January",
    "February",
    "March",
    "April",
    "May",
    "June",
    "July",
    "August",
    "September",
    "October",
    "November",
    "December"
];
const hasMonth = (item)=>MONTHS.some((month)=>item.text.includes(month) || item.text.includes(month.slice(0, 4)));
const SEASONS = [
    "Summer",
    "Fall",
    "Spring",
    "Winter"
];
const hasSeason = (item)=>SEASONS.some((season)=>item.text.includes(season));
const hasPresent = (item)=>item.text.includes("Present");
const DATE_FEATURE_SETS = [
    [
        hasYear,
        1
    ],
    [
        hasMonth,
        1
    ],
    [
        hasSeason,
        1
    ],
    [
        hasPresent,
        1
    ],
    [
        hasComma,
        -1
    ]
];

;// CONCATENATED MODULE: ./src/app/lib/parse-resume-from-pdf/group-lines-into-sections.ts

const PROFILE_SECTION = "profile";
/**
 * Step 3. Group lines into sections
 *
 * Every section (except the profile section) starts with a section title that
 * takes up the entire line. This is a common pattern not just in resumes but
 * also in books and blogs. The resume parser uses this pattern to group lines
 * into the closest section title above these lines.
 */ const groupLinesIntoSections = (lines)=>{
    let sections = {};
    let sectionName = PROFILE_SECTION;
    let sectionLines = [];
    for(let i = 0; i < lines.length; i++){
        const line = lines[i];
        const text = line[0]?.text.trim();
        if (isSectionTitle(line, i)) {
            sections[sectionName] = [
                ...sectionLines
            ];
            sectionName = text;
            sectionLines = [];
        } else {
            sectionLines.push(line);
        }
    }
    if (sectionLines.length > 0) {
        sections[sectionName] = [
            ...sectionLines
        ];
    }
    return sections;
};
const SECTION_TITLE_PRIMARY_KEYWORDS = [
    "experience",
    "education",
    "project",
    "skill"
];
const SECTION_TITLE_SECONDARY_KEYWORDS = [
    "job",
    "course",
    "extracurricular",
    "objective",
    "summary",
    "award",
    "honor",
    "project"
];
const SECTION_TITLE_KEYWORDS = [
    ...SECTION_TITLE_PRIMARY_KEYWORDS,
    ...SECTION_TITLE_SECONDARY_KEYWORDS
];
const isSectionTitle = (line, lineNumber)=>{
    const isFirstTwoLines = lineNumber < 2;
    const hasMoreThanOneItemInLine = line.length > 1;
    const hasNoItemInLine = line.length === 0;
    if (isFirstTwoLines || hasMoreThanOneItemInLine || hasNoItemInLine) {
        return false;
    }
    const textItem = line[0];
    // The main heuristic to determine a section title is to check if the text is double emphasized
    // to be both bold and all uppercase, which is generally true for a well formatted resume
    if (isBold(textItem) && hasLetterAndIsAllUpperCase(textItem)) {
        return true;
    }
    // The following is a fallback heuristic to detect section title if it includes a keyword match
    // (This heuristics is not well tested and may not work well)
    const text = textItem.text.trim();
    const textHasAtMost2Words = text.split(" ").filter((s)=>s !== "&").length <= 2;
    const startsWithCapitalLetter = /[A-Z]/.test(text.slice(0, 1));
    if (textHasAtMost2Words && hasOnlyLettersSpacesAmpersands(textItem) && startsWithCapitalLetter && SECTION_TITLE_KEYWORDS.some((keyword)=>text.toLowerCase().includes(keyword))) {
        return true;
    }
    return false;
};

;// CONCATENATED MODULE: ./src/app/lib/parse-resume-from-pdf/extract-resume-from-sections/lib/get-section-lines.ts
/**
 * Return section lines that contain any of the keywords.
 */ const getSectionLinesByKeywords = (sections, keywords)=>{
    for(const sectionName in sections){
        const hasKeyWord = keywords.some((keyword)=>sectionName.toLowerCase().includes(keyword));
        if (hasKeyWord) {
            return sections[sectionName];
        }
    }
    return [];
};

;// CONCATENATED MODULE: ./src/app/lib/parse-resume-from-pdf/extract-resume-from-sections/lib/feature-scoring-system.ts
const computeFeatureScores = (textItems, featureSets)=>{
    const textScores = textItems.map((item)=>({
            text: item.text,
            score: 0,
            match: false
        }));
    for(let i = 0; i < textItems.length; i++){
        const textItem = textItems[i];
        for (const featureSet of featureSets){
            const [hasFeature, score, returnMatchingText] = featureSet;
            const result = hasFeature(textItem);
            if (result) {
                let text = textItem.text;
                if (returnMatchingText && typeof result === "object") {
                    text = result[0];
                }
                const textScore = textScores[i];
                if (textItem.text === text) {
                    textScore.score += score;
                    if (returnMatchingText) {
                        textScore.match = true;
                    }
                } else {
                    textScores.push({
                        text,
                        score,
                        match: true
                    });
                }
            }
        }
    }
    return textScores;
};
/**
 * Core util for the feature scoring system.
 *
 * It runs each text item through all feature sets and sums up the matching feature scores.
 * It then returns the text item with the highest computed feature score.
 */ const getTextWithHighestFeatureScore = (textItems, featureSets, returnEmptyStringIfHighestScoreIsNotPositive = true, returnConcatenatedStringForTextsWithSameHighestScore = false)=>{
    const textScores = computeFeatureScores(textItems, featureSets);
    let textsWithHighestFeatureScore = [];
    let highestScore = -Infinity;
    for (const { text , score  } of textScores){
        if (score >= highestScore) {
            if (score > highestScore) {
                textsWithHighestFeatureScore = [];
            }
            textsWithHighestFeatureScore.push(text);
            highestScore = score;
        }
    }
    if (returnEmptyStringIfHighestScoreIsNotPositive && highestScore <= 0) return [
        "",
        textScores
    ];
    // Note: If textItems is an empty array, textsWithHighestFeatureScore[0] is undefined, so we default it to empty string
    const text = !returnConcatenatedStringForTextsWithSameHighestScore ? textsWithHighestFeatureScore[0] ?? "" : textsWithHighestFeatureScore.map((s)=>s.trim()).join(" ");
    return [
        text,
        textScores
    ];
};

;// CONCATENATED MODULE: ./src/app/lib/parse-resume-from-pdf/extract-resume-from-sections/extract-profile.ts



// Name
const matchOnlyLetterSpaceOrPeriod = (item)=>item.text.match(/^[a-zA-Z\s\.]+$/);
// Email
// Simple email regex: xxx@xxx.xxx (xxx = anything not space)
const matchEmail = (item)=>item.text.match(/\S+@\S+\.\S+/);
const hasAt = (item)=>item.text.includes("@");
// Phone
// Simple phone regex that matches (xxx)-xxx-xxxx where () and - are optional, - can also be space
const matchPhone = (item)=>item.text.match(/\(?\d{3}\)?[\s-]?\d{3}[\s-]?\d{4}/);
const hasParenthesis = (item)=>/\([0-9]+\)/.test(item.text);
// Location
// Simple location regex that matches "<City>, <ST>"
const matchCityAndState = (item)=>item.text.match(/[A-Z][a-zA-Z\s]+, [A-Z]{2}/);
// Url
// Simple url regex that matches "xxx.xxx/xxx" (xxx = anything not space)
const matchUrl = (item)=>item.text.match(/\S+\.[a-z]+\/\S+/);
// Match https://xxx.xxx where s is optional
const matchUrlHttpFallback = (item)=>item.text.match(/https?:\/\/\S+\.\S+/);
// Match www.xxx.xxx
const matchUrlWwwFallback = (item)=>item.text.match(/www\.\S+\.\S+/);
const hasSlash = (item)=>item.text.includes("/");
// Summary
const has4OrMoreWords = (item)=>item.text.split(" ").length >= 4;
/**
 *              Unique Attribute
 * Name         Bold or Has all uppercase letter
 * Email        Has @
 * Phone        Has ()
 * Location     Has ,    (overlap with summary)
 * Url          Has slash
 * Summary      Has 4 or more words
 */ /**
 * Name -> contains only letters/space/period, e.g. Leonardo W. DiCaprio
 *         (it isn't common to include middle initial in resume)
 *      -> is bolded or has all letters as uppercase
 */ const NAME_FEATURE_SETS = [
    [
        matchOnlyLetterSpaceOrPeriod,
        3,
        true
    ],
    [
        isBold,
        2
    ],
    [
        hasLetterAndIsAllUpperCase,
        2
    ],
    // Match against other unique attributes
    [
        hasAt,
        -4
    ],
    [
        hasNumber,
        -4
    ],
    [
        hasParenthesis,
        -4
    ],
    [
        hasComma,
        -4
    ],
    [
        hasSlash,
        -4
    ],
    [
        has4OrMoreWords,
        -2
    ]
];
// Email -> match email regex xxx@xxx.xxx
const EMAIL_FEATURE_SETS = [
    [
        matchEmail,
        4,
        true
    ],
    [
        isBold,
        -1
    ],
    [
        hasLetterAndIsAllUpperCase,
        -1
    ],
    [
        hasParenthesis,
        -4
    ],
    [
        hasComma,
        -4
    ],
    [
        hasSlash,
        -4
    ],
    [
        has4OrMoreWords,
        -4
    ]
];
// Phone -> match phone regex (xxx)-xxx-xxxx
const PHONE_FEATURE_SETS = [
    [
        matchPhone,
        4,
        true
    ],
    [
        hasLetter,
        -4
    ]
];
// Location -> match location regex <City>, <ST>
const LOCATION_FEATURE_SETS = [
    [
        matchCityAndState,
        4,
        true
    ],
    [
        isBold,
        -1
    ],
    [
        hasAt,
        -4
    ],
    [
        hasParenthesis,
        -3
    ],
    [
        hasSlash,
        -4
    ]
];
// URL -> match url regex xxx.xxx/xxx
const URL_FEATURE_SETS = [
    [
        matchUrl,
        4,
        true
    ],
    [
        matchUrlHttpFallback,
        3,
        true
    ],
    [
        matchUrlWwwFallback,
        3,
        true
    ],
    [
        isBold,
        -1
    ],
    [
        hasAt,
        -4
    ],
    [
        hasParenthesis,
        -3
    ],
    [
        hasComma,
        -4
    ],
    [
        has4OrMoreWords,
        -4
    ]
];
// Summary -> has 4 or more words
const SUMMARY_FEATURE_SETS = [
    [
        has4OrMoreWords,
        4
    ],
    [
        isBold,
        -1
    ],
    [
        hasAt,
        -4
    ],
    [
        hasParenthesis,
        -3
    ],
    [
        matchCityAndState,
        -4,
        false
    ]
];
const extractProfile = (sections)=>{
    const lines = sections.profile || [];
    const textItems = lines.flat();
    const [name, nameScores] = getTextWithHighestFeatureScore(textItems, NAME_FEATURE_SETS);
    const [email, emailScores] = getTextWithHighestFeatureScore(textItems, EMAIL_FEATURE_SETS);
    const [phone, phoneScores] = getTextWithHighestFeatureScore(textItems, PHONE_FEATURE_SETS);
    const [location, locationScores] = getTextWithHighestFeatureScore(textItems, LOCATION_FEATURE_SETS);
    const [url, urlScores] = getTextWithHighestFeatureScore(textItems, URL_FEATURE_SETS);
    const [summary, summaryScores] = getTextWithHighestFeatureScore(textItems, SUMMARY_FEATURE_SETS, undefined, true);
    const summaryLines = getSectionLinesByKeywords(sections, [
        "summary"
    ]);
    const summarySection = summaryLines.flat().map((textItem)=>textItem.text).join(" ");
    const objectiveLines = getSectionLinesByKeywords(sections, [
        "objective"
    ]);
    const objectiveSection = objectiveLines.flat().map((textItem)=>textItem.text).join(" ");
    return {
        profile: {
            name,
            email,
            phone,
            location,
            url,
            // Dedicated section takes higher precedence over profile summary
            summary: summarySection || objectiveSection || summary
        },
        // For debugging
        profileScores: {
            name: nameScores,
            email: emailScores,
            phone: phoneScores,
            location: locationScores,
            url: urlScores,
            summary: summaryScores
        }
    };
};

;// CONCATENATED MODULE: ./src/app/lib/parse-resume-from-pdf/extract-resume-from-sections/lib/subsections.ts


/**
 * Divide lines into subsections based on difference in line gap or bold text.
 *
 * For profile section, we can directly pass all the text items to the feature
 * scoring systems. But for other sections, such as education and work experience,
 * we have to first divide the section into subsections since there can be multiple
 * schools or work experiences in the section. The feature scoring system then
 * process each subsection to retrieve each's resume attributes and append the results.
 */ const divideSectionIntoSubsections = (lines)=>{
    // The main heuristic to determine a subsection is to check if its vertical line gap
    // is larger than the typical line gap * 1.4
    const isLineNewSubsectionByLineGap = createIsLineNewSubsectionByLineGap(lines);
    let subsections = createSubsections(lines, isLineNewSubsectionByLineGap);
    // Fallback heuristic if the main heuristic doesn't apply to check if the text item is bolded
    if (subsections.length === 1) {
        const isLineNewSubsectionByBold = (line, prevLine)=>{
            if (!isBold(prevLine[0]) && isBold(line[0]) && // Ignore bullet points that sometimes being marked as bolded
            !BULLET_POINTS.includes(line[0].text)) {
                return true;
            }
            return false;
        };
        subsections = createSubsections(lines, isLineNewSubsectionByBold);
    }
    return subsections;
};
const createIsLineNewSubsectionByLineGap = (lines)=>{
    // Extract the common typical line gap
    const lineGapToCount = {};
    const linesY = lines.map((line)=>line[0].y);
    let lineGapWithMostCount = 0;
    let maxCount = 0;
    for(let i = 1; i < linesY.length; i++){
        const lineGap = Math.round(linesY[i - 1] - linesY[i]);
        if (!lineGapToCount[lineGap]) lineGapToCount[lineGap] = 0;
        lineGapToCount[lineGap] += 1;
        if (lineGapToCount[lineGap] > maxCount) {
            lineGapWithMostCount = lineGap;
            maxCount = lineGapToCount[lineGap];
        }
    }
    // Use common line gap to set a sub section threshold
    const subsectionLineGapThreshold = lineGapWithMostCount * 1.4;
    const isLineNewSubsection = (line, prevLine)=>{
        return Math.round(prevLine[0].y - line[0].y) > subsectionLineGapThreshold;
    };
    return isLineNewSubsection;
};
const createSubsections = (lines, isLineNewSubsection)=>{
    const subsections = [];
    let subsection = [];
    for(let i = 0; i < lines.length; i++){
        const line = lines[i];
        if (i === 0) {
            subsection.push(line);
            continue;
        }
        if (isLineNewSubsection(line, lines[i - 1])) {
            subsections.push(subsection);
            subsection = [];
        }
        subsection.push(line);
    }
    if (subsection.length > 0) {
        subsections.push(subsection);
    }
    return subsections;
};

;// CONCATENATED MODULE: ./src/app/lib/parse-resume-from-pdf/extract-resume-from-sections/extract-education.ts





/**
 *              Unique Attribute
 * School       Has school
 * Degree       Has degree
 * GPA          Has number
 */ // prettier-ignore
const SCHOOLS = [
    "College",
    "University",
    "Institute",
    "School",
    "Academy",
    "BASIS",
    "Magnet"
];
const hasSchool = (item)=>SCHOOLS.some((school)=>item.text.includes(school));
// prettier-ignore
const DEGREES = [
    "Associate",
    "Bachelor",
    "Master",
    "PhD",
    "Ph."
];
const hasDegree = (item)=>DEGREES.some((degree)=>item.text.includes(degree)) || /[ABM][A-Z\.]/.test(item.text); // Match AA, B.S., MBA, etc.
const matchGPA = (item)=>item.text.match(/[0-4]\.\d{1,2}/);
const matchGrade = (item)=>{
    const grade = parseFloat(item.text);
    if (Number.isFinite(grade) && grade <= 110) {
        return [
            String(grade)
        ];
    }
    return null;
};
const SCHOOL_FEATURE_SETS = [
    [
        hasSchool,
        4
    ],
    [
        hasDegree,
        -4
    ],
    [
        hasNumber,
        -4
    ]
];
const DEGREE_FEATURE_SETS = [
    [
        hasDegree,
        4
    ],
    [
        hasSchool,
        -4
    ],
    [
        hasNumber,
        -3
    ]
];
const GPA_FEATURE_SETS = [
    [
        matchGPA,
        4,
        true
    ],
    [
        matchGrade,
        3,
        true
    ],
    [
        hasComma,
        -3
    ],
    [
        hasLetter,
        -4
    ]
];
const extractEducation = (sections)=>{
    const educations = [];
    const educationsScores = [];
    const lines = getSectionLinesByKeywords(sections, [
        "education"
    ]);
    const subsections = divideSectionIntoSubsections(lines);
    for (const subsectionLines of subsections){
        const textItems = subsectionLines.flat();
        const [school, schoolScores] = getTextWithHighestFeatureScore(textItems, SCHOOL_FEATURE_SETS);
        const [degree, degreeScores] = getTextWithHighestFeatureScore(textItems, DEGREE_FEATURE_SETS);
        const [gpa, gpaScores] = getTextWithHighestFeatureScore(textItems, GPA_FEATURE_SETS);
        const [date, dateScores] = getTextWithHighestFeatureScore(textItems, DATE_FEATURE_SETS);
        let descriptions = [];
        const descriptionsLineIdx = getDescriptionsLineIdx(subsectionLines);
        if (descriptionsLineIdx !== undefined) {
            const descriptionsLines = subsectionLines.slice(descriptionsLineIdx);
            descriptions = getBulletPointsFromLines(descriptionsLines);
        }
        educations.push({
            school,
            degree,
            gpa,
            date,
            descriptions
        });
        educationsScores.push({
            schoolScores,
            degreeScores,
            gpaScores,
            dateScores
        });
    }
    if (educations.length !== 0) {
        const coursesLines = getSectionLinesByKeywords(sections, [
            "course"
        ]);
        if (coursesLines.length !== 0) {
            educations[0].descriptions.push("Courses: " + coursesLines.flat().map((item)=>item.text).join(" "));
        }
    }
    return {
        educations,
        educationsScores
    };
};

;// CONCATENATED MODULE: ./src/app/lib/parse-resume-from-pdf/extract-resume-from-sections/extract-work-experience.ts





// prettier-ignore
const WORK_EXPERIENCE_KEYWORDS_LOWERCASE = [
    "work",
    "experience",
    "employment",
    "history",
    "job"
];
// prettier-ignore
const JOB_TITLES = [
    "Accountant",
    "Administrator",
    "Advisor",
    "Agent",
    "Analyst",
    "Apprentice",
    "Architect",
    "Assistant",
    "Associate",
    "Auditor",
    "Bartender",
    "Biologist",
    "Bookkeeper",
    "Buyer",
    "Carpenter",
    "Cashier",
    "CEO",
    "Clerk",
    "Co-op",
    "Co-Founder",
    "Consultant",
    "Coordinator",
    "CTO",
    "Developer",
    "Designer",
    "Director",
    "Driver",
    "Editor",
    "Electrician",
    "Engineer",
    "Extern",
    "Founder",
    "Freelancer",
    "Head",
    "Intern",
    "Janitor",
    "Journalist",
    "Laborer",
    "Lawyer",
    "Lead",
    "Manager",
    "Mechanic",
    "Member",
    "Nurse",
    "Officer",
    "Operator",
    "Operation",
    "Photographer",
    "President",
    "Producer",
    "Recruiter",
    "Representative",
    "Researcher",
    "Sales",
    "Server",
    "Scientist",
    "Specialist",
    "Supervisor",
    "Teacher",
    "Technician",
    "Trader",
    "Trainee",
    "Treasurer",
    "Tutor",
    "Vice",
    "VP",
    "Volunteer",
    "Webmaster",
    "Worker"
];
const hasJobTitle = (item)=>JOB_TITLES.some((jobTitle)=>item.text.split(/\s/).some((word)=>word === jobTitle));
const hasMoreThan5Words = (item)=>item.text.split(/\s/).length > 5;
const JOB_TITLE_FEATURE_SET = [
    [
        hasJobTitle,
        4
    ],
    [
        hasNumber,
        -4
    ],
    [
        hasMoreThan5Words,
        -2
    ]
];
const extractWorkExperience = (sections)=>{
    const workExperiences = [];
    const workExperiencesScores = [];
    const lines = getSectionLinesByKeywords(sections, WORK_EXPERIENCE_KEYWORDS_LOWERCASE);
    const subsections = divideSectionIntoSubsections(lines);
    for (const subsectionLines of subsections){
        const descriptionsLineIdx = getDescriptionsLineIdx(subsectionLines) ?? 2;
        const subsectionInfoTextItems = subsectionLines.slice(0, descriptionsLineIdx).flat();
        const [date, dateScores] = getTextWithHighestFeatureScore(subsectionInfoTextItems, DATE_FEATURE_SETS);
        const [jobTitle, jobTitleScores] = getTextWithHighestFeatureScore(subsectionInfoTextItems, JOB_TITLE_FEATURE_SET);
        const COMPANY_FEATURE_SET = [
            [
                isBold,
                2
            ],
            [
                getHasText(date),
                -4
            ],
            [
                getHasText(jobTitle),
                -4
            ]
        ];
        const [company, companyScores] = getTextWithHighestFeatureScore(subsectionInfoTextItems, COMPANY_FEATURE_SET, false);
        const subsectionDescriptionsLines = subsectionLines.slice(descriptionsLineIdx);
        const descriptions = getBulletPointsFromLines(subsectionDescriptionsLines);
        workExperiences.push({
            company,
            jobTitle,
            date,
            descriptions
        });
        workExperiencesScores.push({
            companyScores,
            jobTitleScores,
            dateScores
        });
    }
    return {
        workExperiences,
        workExperiencesScores
    };
};

;// CONCATENATED MODULE: ./src/app/lib/parse-resume-from-pdf/extract-resume-from-sections/extract-project.ts





const extractProject = (sections)=>{
    const projects = [];
    const projectsScores = [];
    const lines = getSectionLinesByKeywords(sections, [
        "project"
    ]);
    const subsections = divideSectionIntoSubsections(lines);
    for (const subsectionLines of subsections){
        const descriptionsLineIdx = getDescriptionsLineIdx(subsectionLines) ?? 1;
        const subsectionInfoTextItems = subsectionLines.slice(0, descriptionsLineIdx).flat();
        const [date, dateScores] = getTextWithHighestFeatureScore(subsectionInfoTextItems, DATE_FEATURE_SETS);
        const PROJECT_FEATURE_SET = [
            [
                isBold,
                2
            ],
            [
                getHasText(date),
                -4
            ]
        ];
        const [project, projectScores] = getTextWithHighestFeatureScore(subsectionInfoTextItems, PROJECT_FEATURE_SET, false);
        const descriptionsLines = subsectionLines.slice(descriptionsLineIdx);
        const descriptions = getBulletPointsFromLines(descriptionsLines);
        projects.push({
            project,
            date,
            descriptions
        });
        projectsScores.push({
            projectScores,
            dateScores
        });
    }
    return {
        projects,
        projectsScores
    };
};

// EXTERNAL MODULE: ./src/app/lib/deep-clone.ts
var deep_clone = __webpack_require__(8277);
// EXTERNAL MODULE: ./src/app/lib/redux/resumeSlice.ts
var resumeSlice = __webpack_require__(9056);
;// CONCATENATED MODULE: ./src/app/lib/parse-resume-from-pdf/extract-resume-from-sections/extract-skills.ts




const extractSkills = (sections)=>{
    const lines = getSectionLinesByKeywords(sections, [
        "skill"
    ]);
    const descriptionsLineIdx = getDescriptionsLineIdx(lines) ?? 0;
    const descriptionsLines = lines.slice(descriptionsLineIdx);
    const descriptions = getBulletPointsFromLines(descriptionsLines);
    const featuredSkills = (0,deep_clone/* deepClone */.I)(resumeSlice/* initialFeaturedSkills */.oc);
    if (descriptionsLineIdx !== 0) {
        const featuredSkillsLines = lines.slice(0, descriptionsLineIdx);
        const featuredSkillsTextItems = featuredSkillsLines.flat().filter((item)=>item.text.trim()).slice(0, 6);
        for(let i = 0; i < featuredSkillsTextItems.length; i++){
            featuredSkills[i].skill = featuredSkillsTextItems[i].text;
        }
    }
    const skills = {
        featuredSkills,
        descriptions
    };
    return {
        skills
    };
};

;// CONCATENATED MODULE: ./src/app/lib/parse-resume-from-pdf/extract-resume-from-sections/index.ts





/**
 * Step 4. Extract resume from sections.
 *
 * This is the core of the resume parser to resume information from the sections.
 *
 * The gist of the extraction engine is a feature scoring system. Each resume attribute
 * to be extracted has a custom feature sets, where each feature set consists of a
 * feature matching function and a feature matching score if matched (feature matching
 * score can be a positive or negative number). To compute the final feature score of
 * a text item for a particular resume attribute, it would run the text item through
 * all its feature sets and sum up the matching feature scores. This process is carried
 * out for all text items within the section, and the text item with the highest computed
 * feature score is identified as the extracted resume attribute.
 */ const extractResumeFromSections = (sections)=>{
    const { profile  } = extractProfile(sections);
    const { educations  } = extractEducation(sections);
    const { workExperiences  } = extractWorkExperience(sections);
    const { projects  } = extractProject(sections);
    const { skills  } = extractSkills(sections);
    return {
        profile,
        educations,
        workExperiences,
        projects,
        skills,
        custom: {
            descriptions: []
        }
    };
};

;// CONCATENATED MODULE: ./src/app/lib/parse-resume-from-pdf/index.ts




/**
 * Resume parser util that parses a resume from a resume pdf file
 *
 * Note: The parser algorithm only works for single column resume in English language
 */ const parseResumeFromPdf = async (fileUrl)=>{
    // Step 1. Read a pdf resume file into text items to prepare for processing
    const textItems = await readPdf(fileUrl);
    // Step 2. Group text items into lines
    const lines = groupTextItemsIntoLines(textItems);
    // Step 3. Group lines into sections
    const sections = groupLinesIntoSections(lines);
    // Step 4. Extract resume from sections
    const resume = extractResumeFromSections(sections);
    return resume;
};

// EXTERNAL MODULE: ./src/app/lib/redux/settingsSlice.ts
var settingsSlice = __webpack_require__(522);
// EXTERNAL MODULE: ./node_modules/next/navigation.js
var navigation = __webpack_require__(9483);
;// CONCATENATED MODULE: ./public/assets/add-pdf.svg
/* harmony default export */ const add_pdf = ({"src":"/_next/static/media/add-pdf.d5a58bd2.svg","height":99,"width":86,"blurWidth":0,"blurHeight":0});
// EXTERNAL MODULE: ./node_modules/next/image.js
var next_image = __webpack_require__(8421);
var image_default = /*#__PURE__*/__webpack_require__.n(next_image);
// EXTERNAL MODULE: ./src/app/lib/cx.ts
var cx = __webpack_require__(3619);
;// CONCATENATED MODULE: ./src/app/components/ResumeDropzone.tsx












const defaultFileState = {
    name: "",
    size: 0,
    fileUrl: ""
};
const ResumeDropzone = ({ onFileUrlChange , className , playgroundView =false  })=>{
    const [file, setFile] = (0,react_.useState)(defaultFileState);
    const [isHoveredOnDropzone, setIsHoveredOnDropzone] = (0,react_.useState)(false);
    const [hasNonPdfFile, setHasNonPdfFile] = (0,react_.useState)(false);
    const router = (0,navigation.useRouter)();
    const hasFile = Boolean(file.name);
    const setNewFile = (newFile)=>{
        if (file.fileUrl) {
            URL.revokeObjectURL(file.fileUrl);
        }
        const { name , size  } = newFile;
        const fileUrl = URL.createObjectURL(newFile);
        setFile({
            name,
            size,
            fileUrl
        });
        onFileUrlChange(fileUrl);
    };
    const onDrop = (event)=>{
        event.preventDefault();
        const newFile = event.dataTransfer.files[0];
        if (newFile.name.endsWith(".pdf")) {
            setHasNonPdfFile(false);
            setNewFile(newFile);
        } else {
            setHasNonPdfFile(true);
        }
        setIsHoveredOnDropzone(false);
    };
    const onInputChange = async (event)=>{
        const files = event.target.files;
        if (!files) return;
        const newFile = files[0];
        setNewFile(newFile);
    };
    const onRemove = ()=>{
        setFile(defaultFileState);
        onFileUrlChange("");
    };
    const onImportClick = async ()=>{
        const resume = await parseResumeFromPdf(file.fileUrl);
        const settings = (0,deep_clone/* deepClone */.I)(settingsSlice/* initialSettings */.DF);
        // Set formToShow settings based on uploaded resume if users have used the app before
        if ((0,local_storage/* getHasUsedAppBefore */.pK)()) {
            const sections = Object.keys(settings.formToShow);
            const sectionToFormToShow = {
                workExperiences: resume.workExperiences.length > 0,
                educations: resume.educations.length > 0,
                projects: resume.projects.length > 0,
                skills: resume.skills.descriptions.length > 0,
                custom: resume.custom.descriptions.length > 0
            };
            for (const section of sections){
                settings.formToShow[section] = sectionToFormToShow[section];
            }
        }
        (0,local_storage/* saveStateToLocalStorage */.Wq)({
            resume,
            settings
        });
        router.push("/resume-builder");
    };
    return /*#__PURE__*/ jsx_runtime_.jsx("div", {
        className: (0,cx.cx)("flex justify-center rounded-md border-2 border-dashed border-gray-300 px-6 ", isHoveredOnDropzone && "border-sky-400", playgroundView ? "pb-6 pt-4" : "py-12", className),
        onDragOver: (event)=>{
            event.preventDefault();
            setIsHoveredOnDropzone(true);
        },
        onDragLeave: ()=>setIsHoveredOnDropzone(false),
        onDrop: onDrop,
        children: /*#__PURE__*/ (0,jsx_runtime_.jsxs)("div", {
            className: (0,cx.cx)("text-center", playgroundView ? "space-y-2" : "space-y-3"),
            children: [
                !playgroundView && /*#__PURE__*/ jsx_runtime_.jsx((image_default()), {
                    src: add_pdf,
                    className: "mx-auto h-14 w-14",
                    alt: "Add pdf",
                    "aria-hidden": "true",
                    priority: true
                }),
                !hasFile ? /*#__PURE__*/ (0,jsx_runtime_.jsxs)(jsx_runtime_.Fragment, {
                    children: [
                        /*#__PURE__*/ jsx_runtime_.jsx("p", {
                            className: (0,cx.cx)("pt-3 text-gray-700", !playgroundView && "text-lg font-semibold"),
                            children: "Browse a pdf file or drop it here"
                        }),
                        /*#__PURE__*/ (0,jsx_runtime_.jsxs)("p", {
                            className: "flex text-sm text-gray-500",
                            children: [
                                /*#__PURE__*/ jsx_runtime_.jsx(LockClosedIcon/* default */.Z, {
                                    className: "mr-1 mt-1 h-3 w-3 text-gray-400"
                                }),
                                "File data is used locally and never leaves your browser"
                            ]
                        })
                    ]
                }) : /*#__PURE__*/ (0,jsx_runtime_.jsxs)("div", {
                    className: "flex items-center justify-center gap-3 pt-3",
                    children: [
                        /*#__PURE__*/ (0,jsx_runtime_.jsxs)("div", {
                            className: "pl-7 font-semibold text-gray-900",
                            children: [
                                file.name,
                                " - ",
                                getFileSizeString(file.size)
                            ]
                        }),
                        /*#__PURE__*/ jsx_runtime_.jsx("button", {
                            type: "button",
                            className: "outline-theme-blue rounded-md p-1 text-gray-400 hover:bg-gray-100 hover:text-gray-500",
                            title: "Remove file",
                            onClick: onRemove,
                            children: /*#__PURE__*/ jsx_runtime_.jsx(XMarkIcon/* default */.Z, {
                                className: "h-6 w-6"
                            })
                        })
                    ]
                }),
                /*#__PURE__*/ jsx_runtime_.jsx("div", {
                    className: "pt-4",
                    children: !hasFile ? /*#__PURE__*/ (0,jsx_runtime_.jsxs)(jsx_runtime_.Fragment, {
                        children: [
                            /*#__PURE__*/ (0,jsx_runtime_.jsxs)("label", {
                                className: (0,cx.cx)("within-outline-theme-purple cursor-pointer rounded-full px-6 pb-2.5 pt-2 font-semibold shadow-sm", playgroundView ? "border" : "bg-primary"),
                                children: [
                                    "Browse file",
                                    /*#__PURE__*/ jsx_runtime_.jsx("input", {
                                        type: "file",
                                        className: "sr-only",
                                        accept: ".pdf",
                                        onChange: onInputChange
                                    })
                                ]
                            }),
                            hasNonPdfFile && /*#__PURE__*/ jsx_runtime_.jsx("p", {
                                className: "mt-6 text-red-400",
                                children: "Only pdf file is supported"
                            })
                        ]
                    }) : /*#__PURE__*/ (0,jsx_runtime_.jsxs)(jsx_runtime_.Fragment, {
                        children: [
                            !playgroundView && /*#__PURE__*/ (0,jsx_runtime_.jsxs)("button", {
                                type: "button",
                                className: "btn-primary",
                                onClick: onImportClick,
                                children: [
                                    "Import and Continue ",
                                    /*#__PURE__*/ jsx_runtime_.jsx("span", {
                                        "aria-hidden": "true",
                                        children: "â†’"
                                    })
                                ]
                            }),
                            /*#__PURE__*/ (0,jsx_runtime_.jsxs)("p", {
                                className: (0,cx.cx)(" text-gray-500", !playgroundView && "mt-6"),
                                children: [
                                    "Note: ",
                                    !playgroundView ? "Import" : "Parser",
                                    " works best on single column resume"
                                ]
                            })
                        ]
                    })
                })
            ]
        })
    });
};
const getFileSizeString = (fileSizeB)=>{
    const fileSizeKB = fileSizeB / 1024;
    const fileSizeMB = fileSizeKB / 1024;
    if (fileSizeKB < 1000) {
        return fileSizeKB.toPrecision(3) + " KB";
    } else {
        return fileSizeMB.toPrecision(3) + " MB";
    }
};

// EXTERNAL MODULE: ./node_modules/next/link.js
var next_link = __webpack_require__(1621);
var link_default = /*#__PURE__*/__webpack_require__.n(next_link);
;// CONCATENATED MODULE: ./src/app/resume-import/page.tsx
/* __next_internal_client_entry_do_not_use__ default auto */ 




function ImportResume() {
    const [hasUsedAppBefore, setHasUsedAppBefore] = (0,react_.useState)(false);
    const [hasAddedResume, setHasAddedResume] = (0,react_.useState)(false);
    const onFileUrlChange = (fileUrl)=>{
        setHasAddedResume(Boolean(fileUrl));
    };
    (0,react_.useEffect)(()=>{
        setHasUsedAppBefore((0,local_storage/* getHasUsedAppBefore */.pK)());
    }, []);
    return /*#__PURE__*/ jsx_runtime_.jsx("main", {
        children: /*#__PURE__*/ jsx_runtime_.jsx("div", {
            className: "mx-auto mt-14 max-w-3xl rounded-md border border-gray-200 px-10 py-10 text-center shadow-md",
            children: !hasUsedAppBefore ? /*#__PURE__*/ (0,jsx_runtime_.jsxs)(jsx_runtime_.Fragment, {
                children: [
                    /*#__PURE__*/ jsx_runtime_.jsx("h1", {
                        className: "text-lg font-semibold text-gray-900",
                        children: "Import data from an existing resume"
                    }),
                    /*#__PURE__*/ jsx_runtime_.jsx(ResumeDropzone, {
                        onFileUrlChange: onFileUrlChange,
                        className: "mt-5"
                    }),
                    !hasAddedResume && /*#__PURE__*/ (0,jsx_runtime_.jsxs)(jsx_runtime_.Fragment, {
                        children: [
                            /*#__PURE__*/ jsx_runtime_.jsx(OrDivider, {}),
                            /*#__PURE__*/ jsx_runtime_.jsx(SectionWithHeadingAndCreateButton, {
                                heading: "Don't have a resume yet?",
                                buttonText: "Create from scratch"
                            })
                        ]
                    })
                ]
            }) : /*#__PURE__*/ (0,jsx_runtime_.jsxs)(jsx_runtime_.Fragment, {
                children: [
                    !hasAddedResume && /*#__PURE__*/ (0,jsx_runtime_.jsxs)(jsx_runtime_.Fragment, {
                        children: [
                            /*#__PURE__*/ jsx_runtime_.jsx(SectionWithHeadingAndCreateButton, {
                                heading: "You have data saved in browser from prior session",
                                buttonText: "Continue where I left off"
                            }),
                            /*#__PURE__*/ jsx_runtime_.jsx(OrDivider, {})
                        ]
                    }),
                    /*#__PURE__*/ jsx_runtime_.jsx("h1", {
                        className: "font-semibold text-gray-900",
                        children: "Override data with a new resume"
                    }),
                    /*#__PURE__*/ jsx_runtime_.jsx(ResumeDropzone, {
                        onFileUrlChange: onFileUrlChange,
                        className: "mt-5"
                    })
                ]
            })
        })
    });
}
const OrDivider = ()=>/*#__PURE__*/ (0,jsx_runtime_.jsxs)("div", {
        className: "mx-[-2.5rem] flex items-center pb-6 pt-8",
        "aria-hidden": "true",
        children: [
            /*#__PURE__*/ jsx_runtime_.jsx("div", {
                className: "flex-grow border-t border-gray-200"
            }),
            /*#__PURE__*/ jsx_runtime_.jsx("span", {
                className: "mx-2 mt-[-2px] flex-shrink text-lg text-gray-400",
                children: "or"
            }),
            /*#__PURE__*/ jsx_runtime_.jsx("div", {
                className: "flex-grow border-t border-gray-200"
            })
        ]
    });
const SectionWithHeadingAndCreateButton = ({ heading , buttonText  })=>{
    return /*#__PURE__*/ (0,jsx_runtime_.jsxs)(jsx_runtime_.Fragment, {
        children: [
            /*#__PURE__*/ jsx_runtime_.jsx("p", {
                className: "font-semibold text-gray-900",
                children: heading
            }),
            /*#__PURE__*/ jsx_runtime_.jsx("div", {
                className: "mt-5",
                children: /*#__PURE__*/ jsx_runtime_.jsx((link_default()), {
                    href: "/resume-builder",
                    className: "outline-theme-blue rounded-full bg-sky-500 px-6 pb-2 pt-1.5 text-base font-semibold text-white",
                    children: buttonText
                })
            })
        ]
    });
};


/***/ }),

/***/ 2617:
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "$$typeof": () => (/* binding */ $$typeof),
/* harmony export */   "__esModule": () => (/* binding */ __esModule),
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var next_dist_build_webpack_loaders_next_flight_loader_module_proxy__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(1313);

const proxy = (0,next_dist_build_webpack_loaders_next_flight_loader_module_proxy__WEBPACK_IMPORTED_MODULE_0__.createProxy)(String.raw`C:\Users\saura\Downloads\SmartCV-Resume-main\SmartCV-Resume-main\src\app\resume-import\page.tsx`)

// Accessing the __esModule property and exporting $$typeof are required here.
// The __esModule getter forces the proxy target to create the default export
// and the $$typeof value is for rendering logic to determine if the module
// is a client boundary.
const { __esModule, $$typeof } = proxy;
const __default__ = proxy.default;


/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (__default__);

/***/ })

};
;

// load runtime
var __webpack_require__ = require("../../webpack-runtime.js");
__webpack_require__.C(exports);
var __webpack_exec__ = (moduleId) => (__webpack_require__(__webpack_require__.s = moduleId))
var __webpack_exports__ = __webpack_require__.X(0, [405,655,817,834,487], () => (__webpack_exec__(5566)));
module.exports = __webpack_exports__;

})();